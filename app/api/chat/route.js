// app/api/chat/route.js
import { NextResponse } from "next/server";
import { GoogleGenerativeAI } from "@google/generative-ai";
import { connectToDB } from "@/lib/db/mongoose";
import Chat from "@/lib/models/Chat";

function requireEnv(name) {
  const v = process.env[name];
  if (!v) throw new Error(`Missing ${name} in environment variables.`);
  return v;
}

/**
 * White-box safety: keep context bounded
 * - limit message count (prevents runaway prompt size)
 * - optional: could also truncate long texts
 */
function buildContextContents(messages, { maxMessages = 30 } = {}) {
  const sliced = (messages || []).slice(-maxMessages);

  // Gemini expects: { role: "user"|"model", parts: [{text: "..."}] }
  return sliced.map((m) => ({
    role: m.role,
    parts: m.parts.map((p) => ({ text: p.text })),
  }));
}

export async function GET(req) {
  try {
    // Validate env
    requireEnv("MONGODB_URI");

    // Parse sessionId from query params
    const { searchParams } = new URL(req.url);
    const sessionId = searchParams.get("sessionId")?.trim();

    if (!sessionId) {
      return NextResponse.json(
        { error: "sessionId is required." },
        { status: 400 },
      );
    }

    // Connect DB
    await connectToDB();

    // Fetch chat history
    const chat = await Chat.findOne({ sessionId }).lean();

    if (!chat || !chat.messages || chat.messages.length === 0) {
      return NextResponse.json({
        sessionId,
        messages: [],
      });
    }

    // Convert to simpler format for frontend
    const messages = chat.messages.map((m) => ({
      role: m.role,
      text: m.parts[0]?.text || "",
    }));

    return NextResponse.json({
      sessionId,
      messages,
    });
  } catch (err) {
    console.error("GET /api/chat error:", err);
    return NextResponse.json(
      { error: "Internal server error." },
      { status: 500 },
    );
  }
}

export async function POST(req) {
  try {
    // 1) Validate env
    const GEMINI_API_KEY = requireEnv("GEMINI_API_KEY");
    requireEnv("MONGODB_URI");

    // 2) Parse input
    const body = await req.json().catch(() => null);
    const sessionId = body?.sessionId?.trim();
    const message = body?.message?.trim();

    if (!sessionId) {
      return NextResponse.json(
        { error: "sessionId is required." },
        { status: 400 },
      );
    }
    if (!message) {
      return NextResponse.json(
        { error: "message is required." },
        { status: 400 },
      );
    }
    if (message.length > 8000) {
      return NextResponse.json(
        { error: "message is too long (max 8000 chars)." },
        { status: 400 },
      );
    }

    // 3) Connect DB (singleton)
    await connectToDB();

    // 4) Fetch existing chat history
    let chat = await Chat.findOne({ sessionId }).lean();

    const historyMessages = chat?.messages || [];
    const contents = buildContextContents(historyMessages, { maxMessages: 30 });

    // 5) Add new user message to the model input (NOT yet persisted)
    contents.push({
      role: "user",
      parts: [{ text: message }],
    });

    // 6) Gemini call
    const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);

    // Gemini model name: use the official name you have enabled in your project.
    // Common: "gemini-2.5-flash"
    const model = genAI.getGenerativeModel({
      model: "gemini-2.5-flash",
      generationConfig: {
        temperature: 0.6,
        topP: 0.9,
        maxOutputTokens: 512,
      },
    });

    // Optional "situational awareness" system note (lightweight)
    // If you want stronger steering, include a system instruction:
    // NOTE: Some SDK versions support "systemInstruction" here.
    // Keep it short and practical.
    const result = await model.generateContent({
      contents,
    });

    const aiText = result?.response?.text?.() ?? "";

    if (!aiText) {
      return NextResponse.json(
        { error: "No response generated by the model." },
        { status: 502 },
      );
    }

    // 7) Persist BOTH user + AI messages
    const userMsg = { role: "user", parts: [{ text: message }] };
    const modelMsg = { role: "model", parts: [{ text: aiText }] };

    await Chat.findOneAndUpdate(
      { sessionId },
      {
        $setOnInsert: { sessionId },
        $push: { messages: { $each: [userMsg, modelMsg] } },
      },
      { upsert: true, new: true },
    );

    // 8) Return
    return NextResponse.json({
      sessionId,
      reply: aiText,
    });
  } catch (err) {
    // White-box transparency: return safe message + log internal details
    console.error("POST /api/chat error:", err);

    const message = err?.message?.includes("Missing")
      ? err.message
      : "Internal server error.";

    return NextResponse.json(
      { error: message },
      { status: message.startsWith("Missing") ? 500 : 500 },
    );
  }
}
